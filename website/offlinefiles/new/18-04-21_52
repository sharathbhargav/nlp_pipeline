Can confirm.

The problem is that you really need multiple charts....

In my experience anyone who doesn't do web development considers web development a steaming pile of crap.  And everyone who does web development usually thinks of everything else as stuff 'old people do'.  Like they would be seriously disappointed if, instead of making a website that is accessible by anyone in the world, anywhere (with internet access), you want them to write a desktop application that runs locally...

Almost anyone who doesn't do assembly will acknowledge that it's powerful, but also, pointless in 99.99% of the time.
Yay, I am superior to myself ten times over.
In 9th grade my comp teacher insisted that html was a programming language and drilled it into our minds. We learnt basic python for a month before going back to html. Everyone laughed at me later when I said I did programming in the past and it was html I was very confused
Ajax is not a programming langue.
Seeing how I mostly know C, C++ and perl, I now understand where my superiority complex comes from.
Assembly language.
As someone coming from the computational physics community I'm pretty sure Fortran developers don't even know there exists other languages...
‚ÄúPeople who insist on calling HTML a programming language‚Äù I‚Äôm dead
Scratch programmers have transcended the heirarchy
Why do people call themselves a (insert language here) programmer? I was always under the impression a good programmer uses whatever language is best for the job.
Yep.  Assembly - C - C++...  I feel superior to everyone and wonder wtf is wrong with the lisp people.  
Why is Java so low
Why no haskell or rust?
Python is high up? :P
Maybe java is so low down because most people coding in java are actually working and not circle jerking about which language is superior.. 
Is programming in ADA still a thing?  
We saw some basic stuff about ADA in a course about the history of programming language.  
I know there are those who write with languages such as Fortran, which are "old" but often used in stuff like banking systems, that would require too much work and/or risk of introducing bugs to re-implement in newer languages.  
But I thought ADA had been substituted by the newer generations of OO languages.
Uhm, why the fuck is PHP so far up? That should literally be right next to "People who insist on calling HTML a programming language"
I feel like R should be somewhere to the right of Python?
Where does golang fall? I want to know who to feel superior to.. 
Where are Kotlin programmers who just migrated over from Java?
Compiler Developer should be listed as author of this chart; and someone who feels superior to everyone.   
Forgot Haskell
It‚Äôs Ada. Not ADA. It isn‚Äôt dead. Try doing a proof of correctness for life critical systems in C ;-). That said I wouldn‚Äôt choose it unless it was the right tool for the job. Which is how we should choose languages anyway. 
Where is APL ? The only truly readable functional programing language
You need a two-way between Java and C# devs as well
As a Javascript programmer, I'm just somewhat humbled that someone else would actually consider what I do programming.
What about Haskellers? Or Rust Programmers?
Where is Scala and Haskell on the chart? They gave me a superiority complex for a while
"AJAX Programmer" ..?
What about Visual Basic .net?
Im not insisting HTML is a programing language... just that you can program in it...

*looks around frantically* 
C and Ruby guy, I understand my elitism now.
Ruby isn't just a web language. That's a naive statement.
[APL would be at the top](https://en.wikipedia.org/wiki/APL_(programming_language)).

     (~R‚àäR‚àò.√óR)/R‚Üê1‚ÜìŒπR

finds all the primes from 1 to R.
Where does SQL fit in? Lol asking for a friend
Lol this chart is shit
Loop between Python and Perl detected 
Should SQL be squeezed in above html, give java some credit haha
Pascal programmer here. Java sucks!
The bottom arrow overlap is triggering me
Ruby gems can be written in C, b0ss
As a engineer working with Java, I feel so humble
wb gophers?
As someone who first learned to program in Ruby I feel personally attacked
Hello. I'm a front end dev. I will accept your scorn now.
you forgot to put the DBA at the top mate 
There should probably be different boxes for Pascal and modern Object Pascal. This is a bit like calling C, Objective C and C# "C"...
I am desperately trying to hire some good Java programmers. Java for life.
As a Ruby Dev, I see nothing wrong here
I used to be a VBA programmer and everyone would look down on me. Now I'm a BI Developer and I mostly code in T-SQL and people won't even acknowledge it as an actual programming language so I can't even get in on the jokes anymore! :(
ÊàëÊ≠£Âú®Â≠¶‰π†cËØ≠Ë®Ä
Why all the Java hate man
You forgot Haskell programmers who consider themselves above everyone or "I don't really write code for humans..."
Why is JavaScript anywhere else but in the bottom together with html?
The problem is that the relation does not include all tuples, eg. how do Java programmers feel about Ada programmers? If we assume transitivity, we can at least say Ada people feel superior to Java -- but not vice-versa.

Also I'm clearly at the top, because I'm academically writing C and assembly plus some Haskell and Rust, yeah.
Ruby isn't a web language, so by definition ruby devs know about at least one non-web language
Well, I went from Ruby to Haskell, so I‚Äôm clearly the most superior.
Pretty sure C# is Java so...
Even lower on the chart: Haskell Programmers.  I'd think by now they know their place.
Dang "People who insist on calling CSS a programming language" is so low they aren't even recognized.
The C, C++ and C# section is wrong.
C <--> C++ --> C#
Scala should be immediately above Java... but also below it.
Missing Scala at the top
Wait is lisp programming actually better/harder/something then the others? I'm a newbie to programming but i taught my self lisp to customize a program i use at work...
Wait. Hol up. I would *not* consider myself superior to *Visual basics* programmers, or even JavaScript programmers. The only programmers that I am superior to are BATCH programmers...

Don't see ***BATCH*** on that list now do we?!

Or even ***REDDIT ^MARKDOWN ^^^USERS***
It's good to be king.
This chart forgets Verilog/VHDL programmers, which should be at the top because that's what actually interprets any compiled code and makes the hardware chooch.
>People who refuse to use the word Ajax

Deadpool?
Fuck. Why didn't someone tell me I'd be bottom of the pile when I started a course that solely teaches java! 
Hah as someone who does all his work in Fortran, I feel this chart
Add MATLAB like way below the bottom
Those who code only in Haskell consider themselves as superior to all other programmers, only being inferior to the Monad
Will I be shot if I asked if lua counts as C
Why is JS above Java? ü§î
Lol c# programmers thinking they're superior to c++ programmers


I can't wait to make C my main language. Also, who makes assembly their "main language" when it varies from machine to machine? I mean I'll learn maybe like one or two instruction sets but wouldn't say I'm an assembly programmer
Ajax programmers?
Lua (w/ LuaJIT) is better than all.
I'm surprised visual basic (or any basic) is that high.
I'm surprised Java programmers are so high on the list.
https://www.technotification.com/2018/04/difficult-programming-language.html/amp
Is there any place for these?
Wheres rust?
I'm superior to you all! I program exclusively in INTERCAL!
I can't wait to get my raspberry pi to start learning C. 2 more days
I‚Äôm just starting High School and I just finished my HTML course and I love it so much I think I might pursue a career in it! Is HTML really considered the worst language?
To be fair HTML with CSS is somehow Turing complete. 
What about solidity devs?
You should've titled this, "Ajax is a language" Just to be more click baity.
Ada is a name, not an acronym...
Ajax isn't a language.
What is an ajax programmer?!
I can't help but notice that Labview isn't on here
F O R T R A N
I think it's crazy how in one of these that "Programmers" is misspelled.
Ajax? Asynchronous JavaScript and XML is a programming language now? HTML has a way stronger claim to being a language than a technique. Was this made by an HR rep?
No one even mentions Fortran, it's sad
Why is php above anything? The only thing I think im superior at is dealing with bullshit
What‚Äôs the difference between an Ajax programmer and a JavaScript programmer?
Haha php superior to anything, and other hilarious jokes you can tell yourself.
Haskell: still working out the math
    def rails_dev_here can
        can.confirm!
        true
    end
OO PHP > PHP caught me off guard, made me laugh out loud!
As a Fortran representative, I'm just glad I was included.
So, if I write in a lisp dialect that compiles to Java and Javascript, am I at the top of the stack or the bottom? 
Yes... I did.

I did go through this block by block checking each relationship to ensure it is correct. Therefore I am superior. Period.
Why isn‚Äôt matlab on this list?
Are there even programmers that dont think they are superior? Walking around like writing a recipe is a superpower. Bitch we could be replaced with AI as easy as the rest. Siri build a front end for a non profit that looks for Volunteers .... 
And then there are those who think they‚Äôre programmers because they know SQL
Let's be honest here: s/Assembler/Java/
PHP should be at the bottom. 
Ajax: Spray n wipe
Who the hell are Ajax programmers? 
I would add R and matlab as a link to and from python as well as to eachother. Statisticians and scientists all seem to have a strong opinion on which is the best.
Its mostly accurate imo. The only thing id change is switch Python and Javascript, cause everyone always says that Python is the easiest programming language.
As a SAS programmer, I'm upset that you didn't include the second page of the chart.
"People who refuse to use the word Ajax" -> Ajax programmers

LOL
As a c# developer... I think the arrow should be two up. "We" are superior to php developers 
Tbh Java should be higher in this list. Java programmers think they're superior to almost all of those, except maybe lisp/assembly.

 
Source : am Java programmer. 
"AJAX programmer" is a thing?
Can confirm. C# really gets my dick hard.
Only applies if you lack perspective
How is fortran not completely forgotten about at this point? Please tell me there are no remaining systems that use it. 
where's scratch with everything having an arrow to it
How is js before java
Java is way too low. No way VB or JavaScript devs consider themselves superior to Java devs.
chart does not contain Scratch. 2/10 would not use again
I catergorize myself as a problem solver rather than associate with the language.  Also I'm a problem creator as well
C++, Python, and Java are all completely interchangeable.
Flip the chart and label it "Level of arrogance"

The most arrogant developers I've worked with were front-end, web developers.  Literally HTML and CSS.
Lol perl
People who refuse to use the word Ajax: So you're a Francis Programmer, huh?
The fuck is an Ajax programmer? This is stupid.
Drag and drop programmers (points to every single box)
Is nice to see programming embraces people with speech impediments.
Sadly, I've used every single one of those languages \(except one: Ada\) to produce results.  So, does that make me inferior to everyone or superior to everyone?
This looks like a reverse chart of income though... 
Javascript dev here - that view might have been relevant when the word ‚ÄúAjax‚Äù was still in use, but since then we see ourselves right up there with Ruby and C devs- that flowchart is almost a decade outdated.
As a java developer I'm offended
This is too geared towards web.  What about Go, Julia, Python, R, Scala, Haskell, Rust?  Just seems to be missing a lot of stuff
If I programmed in Ada I'd think I was superior to a lot of languages above it
As a guy who likes C# I feel this is accurate.
What about us App Game Kit programmers? :D
Where is Verilog? 
You can just call the Ajax programmers Francis. 
As a C# programmer I consider myself superior to python  programmers as well.
B-but html is a programming language!
I know how to do like 10 things in HTML and like 2 things in CSS, so I think I‚Äôm pretty firmly rooted at the bottom.
I'm impressed to see C# and Java so far apart, after all are they the same language. Like twins raised by different parents.
As a Ruby programmer, I confirm the asterisk 
Oiii, ASM represent!
This chart is just silly.  Every language needs an arrow out to every other language, because the languages used by other programmers are all much worse than the language that you have actually gotten to know.
Haha I am totally guilty of saying something along the lines of ‚ÄúI would love to learn how to do some programming, I used to build websites with HTML so I‚Äôm sure it‚Äôs similar.‚Äù

And tbh me ‚Äúbuilding websites‚Äù was using angelfire.com website builder and just copy and pasting HTML codes to make minimal things happen. I was probably 12.
Hey! Where are go programmers in there?
I'm not like those other guys, I only say html is a language to fluff up my resume. 
Javas, the supreme beings
Yo but where‚Äôs scratch?
There's no organization to this at all, it's literally just random languages with arrows
The closest I've gotten to programming is goofing off with pennmush/circlemu on RP chat servers *pushes glasses up*

That and creating short batch files to do stuff in Windows :/

My dad did COBOL for like 20-30 years and fucking loves programming, he really wants me to follow in his footsteps but it just doesn't "grab" my interest, despite being relatively easy to understand (at least from what I've been exposed to so far).


I work on a language called Natural (Mainframes). Put us above COBOL. :D
From my experience working at a bank, it‚Äôs the COBOL programmers who have the right to feel superior. The day rate you can command as a COBOL contractor will literally have you laughing all the way to the bank...and then from the bank back to your Ferrari. 
When I first showed up on reddit, it was all Lisp, all the time. 
Honestly I'm just happy to see perl is still being listed on anything
I'm a COBOL programmer learning and building apps in Python .

A key difference is that I had to write all the logic myself in COBOL , in python I can just import a library and use existing functions .
It makes things soo easy .
Most python programmers don't bother writing code since they can just import.
 
Most python programmers would struggle to reverse a string if they had to do it themselves .


> A key difference is that I had to write all the logic myself in COBOL , in python I can just import a library and use existing functions . It makes things soo easy . Most python programmers don't bother writing code since they can just import.

Dude congrats on a long career in Software Development. When are you retiring?
Works for a bank, he just graduated.
Yes, that's rather the point. Not having to rewrite already written code and have a chance of fucking it up.
I agree with the general sentiment, but if you can't even do something as simple as reversing a string, you are not a programmer, you are just a code monkey. You shouldn't have to write everything yourself, but you should have a basic grasp of what the code you are writing is actually doing.

Big standard libraries are great and not having to do all the logic by yourself every time is also really great, but if you don't even understand relatively simple logic you are going to have problems, once you move onto projects that require more self made logic.

In my opinion having a really good understand of logic is one of the best skills a developer can have. Learning a new language and understanding how to utilize it really well, becomes much easier when you understand the logic behind it. 
So does that make python more of a meta-programming language? You just assemble other programs to make your program
It makes it a programming language that has a standard library. So, all of them.
I feel like you're missing the point of the original comment. The joke is that you can write a python app without actually writing any of your own logic.
Only idiots think they are competent enough to write everything by themselves. Save your brains for the logic of what you want to do, not putzing around hacking up solutions to solved problems
    | sed 's/[Pp]ython/JavaScript/g'
I feel your pain of programming COBOL. I too have to put up with that language far too much!
Lol this flow chart completely shits on Java. It's even lower than Javascript.
its fine, move along
Lisp: Riding a unicylce but you have to keep count of how many times you've pedaled with each foot, and if you don't you die.

Assembly: Riding on a 3 wheeled skateboad while trying to pick up every pebble along the way with one of those reach extender gizmos and then trying to find a place for all of those pebbles in your pockets. Oh and if you don't, your skate board catches fire and you die.

Flow chart is accurate.
You have never programmed in Lisp or Assembly, have you?
With pointers/reach extenders and CPU registers/pockets I can kind of see the assembly analogy. I don't know enough about lisp to comment on that one.
I code in C and consider HTML a (markup) language. Where does that place me? 
1996
<html>
<body>
<h1> What did you just say to me, you little bitch?> </h1>
</body>
</html>
I can rite batch file that do work so yes please put above my neighbour who just watch tv. 
/r/gatekeeping
Amazing how low Java is on the list.  I started with C++ and my college switched to Java being the defacto programming language.  Wish that I would have spent that time sticking with C++ at the very least.  Hell, I would have even accepted going to VB at the time.
I think you mean 42c7fae1% of the time
> In my experience anyone who doesn't do web development considers web development a steaming pile of crap.  And everyone who does web development usually thinks of everything else as stuff 'old people do'.

This also explain how fun it is to make architecture decisions in companies that have both strong back-end and web development culture.
In one meeting I saw this exchange:
- front dev A + B:  we need freedom to change params in front end apps
- front dev C: seriously, we‚Äôre the last mile part, it‚Äôs just paralising to wait for your approval to change stuff like timeout values
- back dev D: but we can‚Äôt trust you
- CTO: ...
> web development a steaming pile of crap

web development cranks the pedal down so hard the surroundings get all blury and they don't notice all the people they run over.
I do web development and I can see that web development is a steaming pile of crap
Everyone seems to forget that the hardware you use each day, your OS, and various embedded systems, exist in terms of programming. It‚Äôs slightly annoying to me how a large majority of the content on /r/programming talks exclusively about web dev, or app dev. Then again, the amount of low-level developers pales in comparison to those guys.

I do webdev at times and consider it a steaming pile of crap. Do edge cases get special charts?
And I'm disappointed when an app runs slowly through my web browser instead of lighting fast as a desktop app. Like seriously, HDDs are waay faster than the internet, let alone SSDs, for startup speed, and of course native > js. 
As a former COBOL dev, yes.
> In my experience anyone who doesn't do web development considers web development a steaming pile of crap.

Sort of. I just consider it significantly easier than complex back-ends. The difficulty ceiling of web development is lower than back-end development.
As for whether of not HTML can be considered a programming language, it comes down to imperitive v. declaritive. You are, after all, using it like an interface to a rendering engine.

https://www.youtube.com/watch?v=4A2mWqLUpzw
I heard a team lead the other day compare html and Angular to doing a UI and a codebehind. He isn't quite right, but I understand why he would make the comparison. Html is part of the code, just like xaml is.
But web development IS a steaming pile of crap, I mean, it's pretty hard and sometimes crazy. I don't do that anymore, I leave that to magicians. I do back end. It's relatively easy, also easy to do it wrong ;) The programming language doesn't matter much, but I have my outburst of anti-javascript rage when I suddenly must use it. However, modern JS is not that bad. I mean we don't need to use jQuery anymore ;)
Single quotes! 
Lol that‚Äôs a weird experience...

Maybe I‚Äôm an anomaly but I am strictly a web dev and if any real programmer (yes, do note, I would *never* call myself a programmer) came and said to me that web dev is absolute trash, I would laugh and wholly agree. I‚Äôm of the opinion that web dev is extremely easy and intuitive when compared to most any programming langauge. Sure some programming can be intuitve and flow well but i‚Äôve got an awesome knack for anything logical and my memory is generally unparalleled by others but I wouldn‚Äôt touch real programming with a zillion foot pole made of feet (and not just because feet gross me out, mind you).

I hold very high respect for anyone who has taken the time to learn a true programmers language and mastered it, and especially so if they are able to do my job as well.

Also if you asked me to write a desktop app I would ask for a 2nd set of hands and be thrilled to assist in the project, but the last thing I‚Äôd do is complain that the entire world wouldn‚Äôt be able to access it.
This chart has an obvious flaw - C++ needs double arrows in both directions.
I understood java just fine. HTML and css were a nightmare.
I guess if one squints their eyes, and insists that being Turing complete isn't a requirement, one *could* say that all markup languages are programming languages for the engines they're written for.

One *could* say that, but I wouldn't.
https://m.youtube.com/watch?v=4A2mWqLUpzw

Vindication for you.
I went to college with a guy who ended up teaching high school programing. There is a lot of truth to the saying "those that can't, teach. "
One of my university profs who specialized in programming languages says html is one, so your teacher might have been right.
He wasn't. HTML is a markup language, it even says as much in the name "Hypertext Markup Language".
And who would do just Ajax as their job?
Is the joke that it's not a language or does the author really think it's a language? It's weird the part that says "people who refuse to use the word ajax" AJAX is literally  the act of writing JavaScript which uses a function call(xmlhttprequest).
You're righ
You wouldn't think that were the case reading job listings for web developers...
I have never heard of anyone calling themselves Ajax Programmers
This answers so many questions for me. Why I feel superior (C) but inferior (Fortran ) ..... 
I work primarily in assembly. Bow to me, mortal.
i have an impression of C++ > Java for the longest time
Nah the superiority complex comes from just being a programmer, at least until you have to debug something.
Same here, except replace perl with C# and throw in Ruby and a hint of assembly.
I just call myself an infra guy because it's a more apt description than the technologies I use. I primarilly use Go, C++, and C with a touch of Python. 

* C: We need this to be as fast as possible.
* C++: We want this to be fast but don't want to pull our hair out trying to do simple things.
* Go: We want this to not perform poorly, and be simple and maintainable.
* Python: This project doesn't matter that much, I just want it done fast.

You should use the language that best fits your need. I've seen 100k line Python monolith servers, which is just terrible, but some schmuck made something useful that was small but it kept growing.
I‚Äôm forced to write Assembly language for the Intel 8088 lol 

Edit: for a module in school 
Good point. Though when I got my first computer (Apple ][+) I didn‚Äôt have an assembler, so I wrote in machine language (and it was called that).
You don't know true superiority until you write in-line assembly in high level C++ layers to temporarily undo an architectural mishap baked into ROM. 
Studying physics we learnt Python in freshman year to later do computational methods with Fortran. Those first weeks were painful.
That‚Äôs not true, we also know about [Pascal]
(http://web.mit.edu/humor/Computers/real.programmers)
Exactly, fortran is way too low on this graph unless it's like with ruby that they don't even aknowledge other languages aside from COBOL and BASIC which were the shit back then.
Fortran is great for when numpy doesn't quite do exactly what you want. There are times when I would even choose Fortran over C or C++, just because a few things can come out a bit tidier in Fortran
It‚Äôs all fun and games until you have to add ADA support to a project. 
I've had to explain to one guy at work that we pretty much don't touch any HTML and that's it's all generated a few times now. He just doesn't seem to get it and talks about how I program HTML. 
Technically HTML5+CSS is Turing complete so it could be considered a programming language.
    <option value="dead">Me</option>
It sits only one rung lower than ladder. 
It's name is HyperText Markup LANGUAGE!!!!!!

Edit: guess I should have added a /s.
"Hey there everybody!" 
-some html Dev probably...
Coming from a chart that calls Ajax a programming language. 
Well JavaScript is a scripting language, is call those people out too. I‚Äôm a JavaScript developer. 
Scripting is a subset of programming. Markup is not. 
JavaScript started out as a scripting language, but has since gained sentience and begun to transform.  Like an unholy abomination it surveys features from other languages, and then innumerable projects arise to graft extensions onto it.  What initially began as a project to extend functionality has become a profane altar of darkness whose incalculable evil grows with every addition.  Also JQuery.
As have Matlab users
Me:*uses minecraft commandblocks to host and code a video streaming website large enouth to rival youtube* I HAVE ASCENDED!
Becoming really proficient in a programming language is an investment. It takes time and effort to learn all the features, idioms and gotchas; it then takes further effort to retain them.

In practice most programmers can't just "pull out" the absolute optimal language for the job like a sewing aid out of their Leatherman multi-tool. For each language, they will have their individual "Google Threshold" of how complex the task for implementation needs to be before they run into a wall and need to Google how to do it. If the task at hand is significantly above your Google threshold of a given language L, then L is just out of the question, unless this is a learning exercise to get more familiar with L.

I'm in research. When my boss comes to me and says "I need this gadget ASAP", and the options are 1. Sit down for a while, find the best tool for the job, learn it possibly from scratch, put together something excellent by let's say 4 days from now; or 2. produce something good enough in Python by lunch -- I sure as hell know which I'm going to pick. If I become convinced that there's a "perfect tool" out there that I don't know how to use, and I suspect I might run across a task like this again, I'll put the tutorial in my to-do list.

This is the meaning of being an (insert language here) programmer. It means, "I don't need to do a Google search to write a Fizzbuzz in it". There are dues to be paid for just picking up (insert language here) and using it to hack at a problem. In the magical platonic realm of Computer Science these things don't matter, but in the real world they matter *a lot*.
And that language is Java.   /ducks
Many times there is no objective _best_ language, leaving developers to subjectively choose from their own favorites.
I don't think it's about not being able to use another language, it's more about experience, and/or preference. I definitely consider myself a .net programmer because that's what I've worked in for the last 10 years, and it's what I'd prefer to work in given the chance. I spent a few years as a PHP programmer before, and a year as a java dev. 

That doesn't mean I couldn't jump into another language if I had to, but even though I know "how to program" there's just a lot that comes from experience in a given framework or language. I definitely wouldn't apply for a senior level position as a Java dev because I haven't worked in it for years, however, I'm definitely confident I could be a senior level .net dev pretty much anywhere. 
Because I've spent most of my career on a single language (C++) because my industry/domain (games) generally requires it, and it shows up well on LinkedIn etc. I don't think that makes me inferior or not a good programmer imo - I just advertise and discuss framed around my specialty.
While it is true, the basic are the same for all of the programming languages. So programmer should be able to pick them up quite easily after a few weeks. All the more advanced stuff like C++ templates or different memory model can take a few years to learn.

As a C++ dev I often smell Java devs trying to write C++.
Good Java is not good C++.
It's mostly a circlejerk thing, in reality we use whatever language we have to. 
Because they have inferiority complexes for completely unrelated personal reasons.
I'm a computer programmer.
You can be a programmer in multiple languages. Like i'm a javascript-programmer, an incompetent-C#-programmer, and a meh-python-programmer.  
Of course, If you need to write something fast (a videogame for example), then you should use a language that's fastest, but sometimes you don't have the time to learn a new language.  
  
Sure, you could start using C++ when you don't know it whatsoever, but I'd really not recommend doing such a thing. Also, many people seem to stick with a language they really like and mingle less with other languages.  
I prefer using javascript, whilst some prefer java, and others may prefer C. I'm most experienced with javascript, even though I could code my way through a python project.
Your question contains the answer. 
*when nobody is a good programmer*
Pretty sure this is how religions were formed /grabs pitchfork
They don't, this post is ass
What..? I‚Äôm definitely a PHP developer just cause that‚Äôs always been my job. That‚Äôs what I call myself. Heaps of people do this.
It‚Äôs just a joke. It‚Äôs something we can all relate to. It doesn‚Äôt have to be true. 
Good Engineers do.  Programmers on the other hand, can only see using the tools and task they have in front of them.  So many problems can be solved just with words.  
LISP people are actually superior, so their feelings are justified.
Embedded systems design?
Because this sub only knows one joke. 
Java developers are too busy making money delivering business value to have time feeling superior to anyone.
Yes.
They're a few miles up
They wouldn't fit in the graph - they are at y = -2000.
No time to hate on inferior, impure, badly-typed languages if you are circle jerking with category theory.

edit: You could also express the relation between Haskell and the other Languages as a functor from Hask to the category formed by this chart.
They're in the ivory tower. This diagram is of the dung heap outside.
just cross out lisp and put it there
I think this chart needs to re-written in rust
Nah it fits more or less, it's one of the few languages in the chart whose programmer arrogance doesn't somehow match the learning curve and difficulty of the language :p
Python is sort of a refugee's programming language. People tend to use it to escape whatever bad decisions their previous dev language had. They still respect c/c++ because you need those for fast python projects.
I have programming in Java for 10 years and I have had people constantly telling me Java is the worst and its on it way out since I started.  But here I am, still programming in Java, being solicated for several jobs every month.

People can shit on Java as much as they want but companies like it and seem to want to keep paying me to work with it so ¬Ø\\__(„ÉÑ)__/¬Ø
By that logic, people who think HTML is a programming language must be the hardest workers in the world, because I don't see any of them in this thread.
*timidly raises hand*
LEAVE!
It's Ada not ADA. Not sure why the chart has it all in caps.
I heard Ada was basically like the Rust of the 20th century (in terms of safety and reliability) so it was used a lot in the military.
As someone who works in defense, Ada is still very much in use.
Some Ada is used in aviation systems because it's nice to prove. Fortran is mostly used when it comes to number crunching because it even beats C there, so nothing about old banking systems -- they use Cobol.

Most OO languages suck anyway. Well, OO sucks :D
Ada is more alive than ever :)

You will a few demos example projects here: https://blog.adacore.com
I was taught ADA my first 2 years in University. This was a year ago, they just retired that old system and now teach it in Java. Talking about the programs they do with the guys taking it makes me act like one of those old guys yelling at kids. Back in my day I had to write a function to delete a list and garbage collect, now they just set the list to an empty list.  
US DOD uses ADA for anything mission critical.   
basically there should be a loop. Go down to Java and they look down on Javascript and PHP to continue the loop
Well I don't consider "ajax programmers" to be a thing, so this chart was BS to me.
It's a hierarchy of how superior people feel, not how superior they are.
With JavaScript under it. 
Yeah, C# should definitely be above PHP
Visual basic too, it should be just near PHP
Because the graph only says people who _consider themselves_ superior. So basically it's about what the devs think
I‚Äôm a PHP developer and I think that C# should definitely be above it at least. I think PHP should be above JS, but that‚Äôs just me, I haven‚Äôt even used too much of JS frameworks.
Found the python programmer 
With the amount of hate it gets, yeah, you‚Äôre right. 
PHP is genuinely a shit language though. The list of reasons why PHP is awful or inconsistent is a lot bigger than the list of reasons why JS or similar is awful.
Can you give me an recent examples why PHP is shit? All I ever see is some 6 year old article, that doesn't apply anymore.

>inb4 "weakly typed"

ye that's the point you idiots
Imagine being this out of touch. 
I'm speaking as someone who's currently having to write PHP. Not much, mind you, but still.
The language isn‚Äôt shit, you just suck at it or you‚Äôre using the first version of php.
Haha your triggered
It's not who's superior, it's who they consider themselves superior to
I have to make a PHP project for school and I can feel a cancer forming.

Edit: But then again, our main programming languages are Java and JavaScript, so what do I know.
R master race is above all these peasants.
You feel superior to C++ programmers because you gave a garbage collector and you definitely know the ins and outs of Go, whereas it takes decades to learn C++.
Right next to Rust and Scala.
If you interpret that graph as a category Haskell would be the initial object of that category.
LOL. I once had a job where the industry-standard software was written in APL. Getting an error was like being cussed out by Qbert. What a ridiculous language.
I'm a JavaScript(TypeScript) programmer and I feel superior to all of these. The irrational hate the language gets only fuels my sense of superiority for seeing through it. 
It's an old chart sir.
VB.Net gets a _lot_ more hate than it deserves because people think of it in the same light as they did VB6.

The actual differences between C# and VB.net are pretty insignificant, to the point where I think most developers won't even notice.  The last time I was using both, I think VB.Net had a nice XML literal feature.

It‚Äôs basically C#.NET for people that work for companies that don‚Äôt want to pay you an actual developer salary.
It's not there for the same reason Scala or Kotlin aren't.
Well technically, HTML + css is Turing complete
This is my favourite thing about data science enthusiasts blogging about how Python is fine for any form of intensive processing. 3k words into the article there's a mumbled "by passing everything off to a C program".
Because this diagram is older than 10 years.

>> http://www.terminally-incoherent.com/blog/2007/02/05/programmer-hierarchy/
When's the last time you used JavaScript?
Why should it? Read the diagram correctly
I don't believe you're actually an individual person. I believe you're a representative of an equivalence class that's gained sentience.
At least you repented your sinful, impure ways and accepted the glory that is Haskell in your live. In the name of Curry Haskell and Simon Peyton-Jones you are forgiven.
Technically C# would be OO Pascal. Same creator, many similar semantics.
Technically Delphi would be OO Pascal.
Good point. I see Niklaus Wirth isn‚Äôt mentioned much anymore.

Still, I write Java and Pascal and the similarities are not to be ignored.
Aw hell no. Compare Mono on one hand with Eclipse or IntelliJ on the other.

Edit: mono *develop*.
Why are you comparing an open source implementation of .NET with two IDEs?
Because he ran out of ideas how to defend Java...
I like Java because it's the best viable tool set for enterprises. I also like it because for some reason there are a lot of people hating it and thus being a senior enterprise java dev pays a shit ton. Also for **some** reason it's the most needed technology at the moment in the industry if you bother to look up the job market.
JavaScript dev probably!
That's like asking I love painting... Why this isn't considered math... They are both challenging and useful.butnl you can't compare them. And you should learn JavaScript too... That's a language
HTML is not a programming language. HTML is basically a file format, specifically one used to express website layouts. The other things on this chart don‚Äôt do the same thing, and are not meant to be a replacement for HTML in any way.

If you want to do frontend web development, which is the industry term for what you‚Äôre probably thinking of, then you have to use HTML/CSS/JavaScript because that‚Äôs just how the internet works. You don‚Äôt really get a whole lot of choice in that scenario.

Also in general there are no ‚Äúworst‚Äù or ‚Äúbest‚Äù languages, it‚Äôs mostly personal preference, and *sometimes* it depends on the context of what you want to accomplish too.
    #include <cstdio>
    
    int main() {
        char *b = "\xe1\xfa\xc7\x42";
        float *f = reinterpret_cast<float*>(b);
        printf("%f\n", *f);
        return 0;
    }

>> 99.989998

holy crap
As a software architect, I can confirm that finding the balance between freedom to create interfaces and not fucking up the system is very difficult. 
*Exchange reformatted for readability:*

>This also explain how fun it is to make architecture decisions in companies that have both strong back-end and web development culture.  
In one meeting I saw this exchange:

> - front dev A + B:  we need freedom to change params in front end apps

> - front dev C: seriously, we‚Äôre the last mile part, it‚Äôs just paralising to wait for your approval to change stuff like timeout values

> - back dev D: but we can‚Äôt trust you

> - CTO: ...
I do databases, web services, windows services, WPF, Web and Xamarin. And all the other stuff that entails. 

I hate the fucking lot. 
Yeah, I was gonna say both those who do and don't do web development acknowledge that it's a steaming pile of crap. 
Full stack developers hate themselves twice every morning.
backend development is worse than front end. writing and styling markup is a bitch but it affords you a lot of creativity that you don't get when doing backend development
Web development is flashy and hip. Those who do it or are interested in it tend to also be more engaged in social media, which is why you see more web development shit discussed on reddit. However, this doesn't stop them from giving their narrow opinions on back-end languages like Java and what it can do.
I want to belive you. But 90% of job opening I see list front end as a least desirable skill. Jobs are listed as either front-end or full stack. I'm seeing hardware companies listing Node.js as a required skill. I mean what the fuck?
I think it depends what your interest is. It's undeniable that the web is the best delivery model we have. If you want to be a product developer, it's the really the best place to do it. The web is much more powerful than even 5 years ago. Heck, you can even make websites work offline now.

There isn't a lot you can't do with the web these days in terms of product development.
http://werc.cat-v.org/
maybe you'll like this
That's the case with pretty much all languages I think.

Not the HTML one though, that one is accurate.

And there are nowhere near enough arrows pointing at JavaScript and PHP.
Also the entire chart circled, pointing and laughing, around PHP.
Am c++ programmer, am humble about it. I‚Äôm just glad I don‚Äôt *have to* program in the other languages (except some occasional python). 
I can see CSS being  sort of a nightmare but HTML? really?
How it's so much than any real language easier that my grandma could figure it out.
In this list where would you rate English?
Below HTML
HTML5 + CSS3 is Turing Complete
[These guys](https://i.imgur.com/YZY0Jc0.jpg)
Many people did it back in the day. Nobody knew what they were doing, and they obviously didn't knew what they were doing. Most of the Ajax developers became jQuery developers (not developers of jQuery, but jQuery developers).
I don't know, but it sounds like a pretty easy gig.
I had an internship writing AJAX for Magento.     
    
Worst. summer. ever.
Aye, once upon a time it was literally called `Asynchronous JavaScript and XML`

I'm prone to think that OP isn't a programmer, it looks like he might be a [Printer Salesman](https://www.reddit.com/r/videos/comments/84nfot/ink_cartridges_are_a_scam/dvrkf3e/)
The joke is so old that "ajax" was still a new concept when this was drawn.
You're hig
I laug
1 no

2 goto 1

Yeah I can't do assembly, because I didn't learn to code in the 70s
No, no. You have that correct.
I learned arm assembly for fun and a friend needed assembly for a robotics project. Never think less of assembly, it will never go out of fashion as long as people try to do real time calculations on small embedded systems, so never.
Same, but with 8085 
I think all programmers should learn to deal with assembly. Not because most programmers will ever use it, but because it gets you closer to the machine and forces you to really learn and consider what is going on. It teaches discipline and makes for a better programmer.
Machine code is literally 16-bit hex-code (in x86), you wrote in hex code?  I've heard of people doing that and it's fucking impressive as hell.  Just wondering if you meant assembly (assembly code is human-readable instructions (STOR, etc) that are representations of the actual 16-bit x86 instructions (which are numbers applied to the instruction registers).  

Chris Sawyer wrote the entirety of the first Roller Coaster Tycoon game by himself in x86 assembly, which is probably the single most impressive programming feat I've ever heard of.  
I envy you. We went straight to Fortran and c. But Python was long-term the most useful...
Pascal was my favourite language for many years (though I had to translate most science routines from FORTRAN). I now write in Python.
Legacy RPG... That's *never* fun.
Designing and building complicated injection-molding machinery is not the same as making dildos, even though dildos are the end result 
Wait you really generate your HTML?  From my experience the only way to get a good actually responsive website to write it yourself.  Like if you want to make drop downs and logins for example.
Even if that's true (I'll not bother to look it up, and just trust you that it is), lots of things are Turing complete that you'd never call a programming language.

Microsoft PowerPoint is Turing complete.  
Conway's Game of Life is Turing complete.  
Magic the Gathering is Turing complete.

I completely get the argument, but I think we lose something in the discourse if that's all that is required to be called a programming language.

[So is Powerpoint but I don't see it on the flowchart.](https://www.youtube.com/watch?v=uNjxe8ShM-8)
Forgot your 
> selected=‚Äúselected‚Äù
And like English, any language is a programming language.
Almost a really geeky Sparta reference
Aka MatGraph
Did you know Matlab is not free software? Have you considered switching to the better free alternative Octave? /s
Ye fool, I will show you the one and true way, before this chart could have ever have been conceived...

*CARD PUNCHING INTENSIFIES*
Perfect is the enemy of good

"Good 'nuff" is the friend of lunch.
I like Java a lot actually. I've never understood why people trash it so much. We all know the worst language ever invented is Objective-C or as a friend use to call it "moon code"
"And other jokes you can tell yourself"
*blam* HERESY
fite me irl
I am really new to programming (I know c++ and java, and that's it so far) but I like Java. I find it really easy to make visual programs with it. Why do people hate it?
What i meant was, if i'm throwing together something quick and dirty like a cron job or a something to generate a report, i'll probably use php or python. If i'm coding for a microcontroller, C++, if i'm building a large project almost always use Java. Basically I think people should stop identifying as a "specific language" programmer.
Figuring out how to work with the pain-in-the-ass dumb-shit quirks every language has is half the battle.
I've been doing .NET for about 7 years, did Ruby for a year or two prior, and applied for a Sr Golang/Ruby position. The Golang was fine, but my God did I completely bomb the Ruby portion of the interview.
I have only one thing to say to you.   
   
    (this ()()
      ((()()
          (((()))(is()
      (((()(())(
          ((()(
              (((((dumb.))))
          ))))))
      )))))
Video game development.  Which is effectively embedded systems.  Got to go fast.  
If you branch a bit higher up to server infra, check out Go. It's like C but has a garbage collector, built in threading, and is way more maintainable. That being said, it is slower so choose the language that fits the needs.
Arrays start at 0 lol XD
Java programmers are too busy making half as much as C++ and Python devs because they don‚Äôt work for actual tech companies more like it...
Can confirm. I barely know Haskell but already feel my superiority
[relevant xkcd](https://www.xkcd.com/435/)
By the way. Who the fuck let that dirty Java peasant in and gave him lambdas?
That‚Äôs why we think it‚Äôs the best language. No bloat and no bullshit. The only downside I can think of of python is speed, but the python interface over a C library paradigm (eg numpy, Tensorflow) solves that problem beautifully.
You dropped this \ 
 *** 
^^&#32;To&#32;prevent&#32;anymore&#32;lost&#32;limbs&#32;throughout&#32;Reddit,&#32;correctly&#32;escape&#32;the&#32;arms&#32;and&#32;shoulders&#32;by&#32;typing&#32;the&#32;shrug&#32;as&#32;`¬Ø\\\_(„ÉÑ)_/¬Ø`&#32;or&#32;`¬Ø\\\_(„ÉÑ)\_/¬Ø`

 [^^Click&#32;here&#32;to&#32;see&#32;why&#32;this&#32;is&#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Americans with Disabilities Act
That had me wondering if OP in fact meant Ada the language, or something else with the acronym ADA that I wasn't familiar with.  The position seems weird to me as well.  Wouldn't most Visual Basic programmers be like "what the FUCK is an Ada?"

My impression is that it would have a double-sided arrow with C programmers, because "It's just C but slower and too verbose", but "It's got a lot of nice features that make it way more secure and focused than C", and so on.
You beat me with this comment
Wait but isn't JavaScript the same as Java? /s
Same. WTF is "Ajax programmer" even supposed to be? Someone who know how to use XmlHttpRequest in JS? Someone who uses client-server architecture?
Nah, JS deserves a higher ranking than PHP
Nah, maybe before Node existed but JS is back to being a ‚Äúfancy‚Äù language now. Also JS is absurdly fast nowadays, like almost unreasonably so.
I think C# is amazing. Easy to write, easy to use, hugely flexible. Sure it might be complex under the hood, but it obfuscates all the crap I don‚Äôt need to worry about so I can work on the problem at hand, not work on fixing the problems the language gives me
Right?! I am curious about this fictional universe where VB programmers consider themselves superior to Java devs.
Dunning‚ÄìKruger effect.
That's not how you read that diagram at all either way
This made me push out more than usual amount of air trough my nostrils.
Typescript is pretty freaking sweet. All the benefits of javascript like portability but with some real structure that makes it so much easier to manage if you are writing more than handful of functions.
To be honest I mostly see praise for JavaScript, especially since Node came out. 
Ueah man, literalls kick ass. I wish c# had it
Vb doesn't require parenthasis, allows you to pass propertied by reference and supply a default value, God knows what that does. Tons of implicit casting that doesn't directly translate, and late-bound-resolution. Not to mention the weirdness legacy support like arrays being declared as length = max index or what ever.

I converted our entire codebase to c# and you would not believe how many bugs and compiliation errors there were. 

That said I assumr if you use all of the strict options and warnings as errors it isn't too bad. It might just be that it is a language meant to be easy to pick up for non-programmers which means you see a ton of bad-practices or weird issues?


Sure, but so is Powerpoint
You shut your filthy document mouth!
I was questioning this until I realized you could probably reasonably make GoL with HTML and CSS and GoL is Turing complete. So huh, I guess that‚Äôs true...
That's css, not html.
nowadays you can pass everything off to a *rust* program! Get the same speed, but without the fun crashes because you fucked up.
Lol, this is very true, I was speaking to Ruby devs not recognizing non web langs.. though this is true of *most* Ruby devs
You‚Äôre kind of missing the point, yea you pass it off to a C program but the important part is that the python library you need written in C definitely already exists
I don‚Äôt get what you mean. The entire python data science stack is written in C with a python layer on top, but the whole point of it is not having to interact with the C layer or write any C code. You‚Äôre not passing off anything to a C program, you‚Äôre still writing only python code, it‚Äôs just that python is calling routines that are native C code under the hood. It gives you all the speed benefits of calling C code with all of the flexibility benefits of writing python code.

Pretty much every non-native language has libraries written in C though, so it‚Äôs not really python specific.
That explains the lack of rust, which is better than every language ever to have existed. /s but not /s
Given ~ is the equivalence relation ‚Äúwrites code only in the superiorist languages‚Äù
Why write the hex like that?
r/theydidthemath
In my defence they only specified 2 points of precision.  :)  Yes, I used to teach assembler :(
Nonsense! All you have to do is wrap all the new front end parameters in try/except blocks so you can catch their bugs and throw it in their face with aptly named error messages. 
You're telling me. My team is desining a system to move from a NoSQL db to a NewSQL. 

The number of people trying to fuck up the new API is too damn high. We ended up exposing a very restrictive api to a very powerful database, but everything we do expose we have very strong guarentees. 

But, inevitably, I'll get roped into a meeting where I need to tell some team across the company "Your idea would work for your scenario but it's still a bad idea for reasons X Y and Z. It is hard to argue with other engineers on design principals when they're idea would technically work.
It's cyclical

First we want things nice and contained in our own little boxes

Then that becomes difficult and expensive to maintain so we want to open it up, let the applications roam free in the wide open plains of the enterprise / internet

Then we get paranoid and build fancy new little containers for our secrets to go into

Then, from the basement, we peek out at the sun coming up on a Spring day...
Can confirm.
It's not just 'hip', it also has vastly more demand since it is closer to the user level, and it has the flexibility to be constantly changing. Stability and backwards compatibility is a much bigger concern on system development. So yea, way more jobs in web dev and constant changes and new shit, of course it will dominate any general programming forum.

Also Java is a turd, it can do anything, just slowly with 10x the boilerplate factoryfactoryfactory. Also backend != embedded systems , that's another level.
> Also Java is a turd, it can do anything, just slowly with 10x the boilerplate factoryfactoryfactory. Also backend != embedded systems , that's another level.

Not sure if trolling, given I just said this:

> However, this doesn't stop them from giving their narrow opinions on back-end languages like Java and what it can do.
Hey, 28f272fe556a1363cc31, just a quick heads-up:  
**belive** is actually spelled **believe**. You can remember it by **i before e**.  
Have a nice day!

^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Yeah you're right, looking at the whole chart, obviously VB and Java programmers think they're better than Javascript/Ajax/PHP programmers. The chart doesn't make a whole lot of sense. Let's agree that we all consider ourselves superior chart makers.
\>_> I happen to like HTML
I mean, I think it's implied that people consider themselves superior to anyone lower on the chart, isn't it? 
If you don't know how to use CSS, HTML is a nightmare. Endless. Nested. Tags. And. Inline. Styles. I have to deal with this atm due to... don't even ask. I got no clue if this is bad machine generated code or an even worse webdev than me who got loosed on an absurdly simple website. Either way it's a chore to unfuck.
I don't understand the problem people have with CSS?
No it isn't.  
And they're clearly inferior to the rest!
They didn't do their job this year though!
Fuc?
He protec  
He attac  
But most importantly  
He ajac
x86_64 and mips here for finance; gotta squeeze those nanoseconds.
How difficult is Assembly? I am going to need to learn it in a couple semesters for my Operating System's class, but I am super nervous. Is there a good place like Sololearn that teaches it?
Rust is getting really good at small embedded systems.
how is it better than embedded C?
I've never heard embedded C but from my knowledge, any compiled language has to be slower and bigger than its assembly equivalent.
For a class I‚Äôm taking now, I have to get familiar with it (we have to generate C code by looking at the assembly), and once you get the hang of it, it‚Äôs pretty much like a puzzle. 
Likewise with Rollar Coaster Tycoon 2!
 > 2!

2! = 2


I should specify I wrote in 6502 machine language. Yes, I used graph paper, and memorized the hex codes for the common operations. Then I‚Äôd type the code into the memory editor. 

Mind you, I didn‚Äôt make anything very elaborate this way.  500 bytes was my biggest routine. It flipped the speaker on and off (there was no digital to analog converter) with frequency-modulated noise to simulate battlefield sounds (machine guns and whistling bomb drops at random intervals). Useless, but fun.

Edit: oh, but it had a built-in *disassembler*, so I could check my code (though no symbolic variables).
He said he didn't have an assembler.
Do physics modelling in python to this very day, still don't get what the fortran nonsense is about.  
RPG developers, there are dozens of us!
Ergo all injection moulding leads to dildos.
I think text-based things that are Turing complete could be considered languages. Obviously Microsoft PowerPoint isn't because PowerPoints aren't typed out as plain text.
Even that I don't think is a good definition. There are visual drag & drop style languages that I do think count. There is an esoteric language that has its source code in the form of images (Piet) that I think also counts.

I personally don't think there is a simple answer to this.
Programming languages are like pornography: I can't define it, but I know it when I see it.
Aka "anything python can do, but confusing" 
What Java does right is documentation.    It may not be the fastest or most efficient, but at least there is useful documentation for everything. (Looking at you Microsoft languages) 
It used to be slow and it‚Äôs pretty verbose, but it isn‚Äôt slow any more and if you use Kotlin you can keep the best parts of it while using a beautiful language complete with null safety and diabetes-inducing levels of syntactic sugar. It‚Äôs amazing. 
I like java because it is really strict, as in there tends to be one obviously right way to do each thing. It‚Äôs also really readable, if you have a nice editor and enough time to jump between all the files.
I don't know, I like Objective-C. It's like a Pug, it has breathing problems, it's hard to maintain sometimes, some may argue it's ugly but I just find it super cute so let me defend it :

- it's C or C++ (Objective-C++, just rename your file to `.mm`), and it's stupidly easily interoperable with both (JNI sucks, really)
- it's faster than Java and it consumes less RAM (ARC, no garbage collector, faster method invocations)
- it has most if not all Java language (don't JSR me) features (thread sync, reflection, annotation/preprocessor macros, module system, exceptions, finals/readonly properties)
- it produces native executable with all non-OOP stuff running at the same speed as C ('coz it's C)
- it's runtime is tiny compared to the JRE
- I don't end up with 452 150 files with just our corporate license header and a three lines enum. I can put as many code as I want in my file, 'cause it's my job to know how to write readable and maintainable code

My pug is ugly but it's still better than a Yorkshire Terrier.
One of the the things objective-c gets trashed for but I think gets it right is named variables. The language is self documenting. Consider the following function call as it would appear in most OOP languages.

    new CountDownTimer(3000, 1000)

What does this mean?
Now here it is in Objective-C

    [CountDownTimer newWithTotalTime:3000 interval:1000];
As a sysadmin who had to support it. Tomcat is needlessly complicated. Garbage collection is always a problem. When there are problems all the webdevs can suggest is restarting the JVM. No one wants to actually do any debugging. So yea... Fuck java.  
  
Outside of that they have some neat tools. Junit, jetty, gradle, etc.
I'm not trashing Java. I love java. Unless there's a specific need for a different language, I usually go for Java. It's a mature language with lots of libraries, runs pretty much everywhere, great threading and network support, great choice of mature, feature-rich open source IDEs. Sure, it can't match C++ for pure speed on some types of computation but yuck - C++.
Because you can‚Äôt do `1.times` in java using an overly expensive mac text editor in a starbucks
Some perceived problems with Java:

* Incredibly verbose
   * No type inference
* Sucks at domain modeling
   * No sums or unions
   * No pattern matching
   * No DSL syntax √† la Haskell `do` notation/F# computation expressions/Scala `for`-`yield`/C# LINQ/...
   * Not even async/await
* Unnecessary boxing all day err day
* Dependency hell

Contrast with: F#, Rust, TypeScript (no I am not a gigantic hipster, yes these are fantastic languages for Getting Shit Done)

Special mention for Go, the best of all bad languages.
My favorite thing about Java is how everything is a pointer. The language handles all the shit for you, no need for delete commands, copy constructors, etc. The garbage collector is a lifesaver. It's easy to write and not worry about accidentally failing to make a deep copy or missing a referencing operator somewhere.
It's the little things, generating the little getters and setters for fucking everything, and they're always the same, there's never any other logic needed there besides `myInstanceVar = theOneIGotAsArgument` or `return myLocalVar`. There is literally no difference between this and simply making the instance vars public instead, and having getters nor setters. This is one thing that C# gets right: you have instance vars, and if you need logic in the getter, or the setter, for it, only then do you type more things. So even though I have no big beef against Java and even have a little swimming diploma for it.. I really don't like the love it has for boilerplate.

I also think having to compare strings with `strA.equals(strB)` is a programming language bug / monstrosity.
Mainly because it's incredibly verbose, inefficiently slow, and a memory hog. It still remains one of the most accessible concurrent/enterprise languages, though.
I've done very little in objective-c, but I found it an elegant OOP layer on top of C. It also had a fantastic environment. Why do folk hate it? 
I like Objectice-C a lot actually. I've never understood why people trash it so much. We all know the worst language ever invented is JavaScript or as a friend used to call it "milk code"
Java sucks, the JRE sucks, the legacy java classes suck (looking at you all 20 thousand different date and time classes), Its async support sucks, it has almost no continuity, it requires multiple dependencies just to have any hope of functioning at all.  There is NO saving grace for java, it had its time, now it is time for it to die.
Java doesn‚Äôt have properties
Swing layouts.
Verbosity. Boilerplate. Requires a big bloated IDE to even read the code, even more to write. Just not fun at all. If I want something fluffy high-level nice to work in there are languages like Python or Clojure. If I want something fast there is C and C++. Java is a compromise I never wanted.

Almost 10 years as a Java programmer, still use it at work now and then, but never if I have a choice.
It's very verbose compared to higher level languages, and uses a lot of system resources compared to lower level languages. So it gets hate from both sides.

Also I hear it's commonly used in CS courses, which I expect is a lot of people's only exposure to it.
cause Oracle made it so easy to hate
But less experienced ones can programm in only one family of languages e.g. I like C++, I can do Java, but I've no idea what the hell is Haskell or ACK, yet. So in some cases calling myself a (insert name here) programmer makes sense. 
People still have a favorite. Like what's your favorite food? Are you a dog or a cat person? Who's your favorite artist? You can do or like multiple things while still having a favorite.

Also, a lot of developers spend the vast majority of their time with one language, so they are that type of programmer.
I tend to gravitate towards Java or C#. I find it hard to go wrong with Java since you can make it work on practically anything and it has libraries premade for basically everything. It's also core to Android (though now there's this newfangled Kotlin thing I have to learn. Sheesh).
I think most programmers don't need to do tasks that differ so much. If my job is writing web apps in Node, then I'm a JavaScript programmer. I'll never be asked to write code for microcontroller, so I don't need to know C++.

(Whether limiting myself so much is a good decision for my career is of course another question.)
If I'm working on a personal project, I'm way more likely to use my favorite language - even if it's not a perfect fit. And with every project I gain more experience & build more libraries that make that language a better fit for that domain :)

And it's led me to build a wide array of things using a common set of tools: web servers, web clients(compiled to JS), build systems, CLI apps/clients, a desktop notification server, automation for Kerbal Space Program, TUI applications, data migration scripts, etc...

It helps to pick the right favorite language ;)
When you only own a hammer, the only job you can do is nailing.
> pain-in-the ass-dumb-shit quirks

***

^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
If I were applying for something like that I'd just make it abundantly clear that I didn't have experience in that language, so if part of their requirements were being able to know it without any resources, I wouldn't be a fit. 

Not that I couldn't build something in ruby, just that I couldn't do it off the top of my head like I could with .net.

Now, the matter of whether I'd actually ever even consider working  in ruby full time is another topic altogether. 
> All told, a monad in X is just a monoid in the category of endofunctors of X, with product √ó replaced by composition of endofunctors and unit set by the identity endofunctor.
Look at things other Haskellers do & feel your inferiority.


*nods in approval*
They are not *real* lambdas, are they?
I hate non-strictly typed languages and think white space should never be an operator. Also, the lack of type safety means than complicated generics are basically impossible to read and debug.

That being said, I've used Python for small quick and dirty projects. It only starts to really suck when the service gets too complicated.
The speed is the "bloat and bullshit" behind python and hiding it behind prewritten C code often doesn't help. Sometimes Cython relieves it a bit but it also introduces some complexity.
And whereas Java's JNI is imitidating, Python's interaction with C is beautifully simple and easy to use. 
Thanks bot!  I'm on a phone and too lazy to fix it.
Are you okay?
I first saw this chart back in '07, when AJAX was the buzzword du jour. In this context basically (sorta) means SPA devs.
They're the same as HTML programmers if I had to guess.
Someone who uses $.ajax({url: ... 
PHP at least sucks on *their* machine while javascript sucks on mine.
Nice jokes mate
Found the PHP developer!
Everyone is superior to Java devs in this universe. 
As a Java dev who got started with Angular last year I love it as well. It makes JavaScript bearable for me :)
Not from me :) 
[You can't just say that without linking it!](https://www.youtube.com/watch?v=uNjxe8ShM-8)

And [magic the gathering](https://www.toothycat.net/~hologram/Turing/index.html) and  [printf](https://github.com/HexHive/printbf)
He wrote it byte by byte in little endian

1 char = 1 byte
hmm yes, an int would have been easier I guess. I am used to the notation from shellcodes which are more than 8 bytes, so don't easily fit into an int. Also in an int you need to care about endianess.
Found the python dev 
Exceptions ruined programming.  That, and curly brackets.  C++, burn in hell.
I too enjoy hard crashes that bring down the program.
That is pretty much the standard for low level programmers, it is better to crash the program when an error occurs than it is to continue with potentially unexpected behavior. 
Basically all of Windows 3x
I second this man! 
I hope you will be forced to write assembly forever in hell. 
No exceptions or curly brackets there!
woo look at this troll
As a security guy, the restrictive API with strong guarantees sounds pretty damn good. I'm not seeing the issue?
Me --> everyone else. This is the underlaying algorithm for all charts
I think java and JavaScript are reversed. 
Actually I think JS developers see themselves superior to PHP developers. Thanks to Node.JS
Nothing wrong with HTML but no matter how you look at it it is a markup language.
Yeah but quite a few of the groups mentioned consider themselves superior to anyone higher on the chart as well.
The code generated by something like Microsoft word can be the stuff of nightmares. Best of luck
But it's not actually confusing. It's just messy. Anything generated is clearly horrible, but decently written html is just kinda long. 
Maybe it was [this guy?](https://www.reddit.com/r/ProgrammerHumor/comments/8dm09t/a_little_html_and_pasiance_is_the_key/?st=JG9NTKJN&sh=b53d5ccf) 
They may be inferior to the REST but they are still superior to SOAP. 
the zucc
Assembly is not that hard (I worked with Mips32). What you do have  to take into account is that:  
1. Things take longer to do. Something that you can make in 5 lines of code in other languages might take 10 times more lines in Assembly.  
2. You need to manage the registers. You have limited space to work with (unless you use the stack, but that means making your life harder).  
Aside from that, it's not so different from learning another Programming Language from scratch. I would not worry too much.
There's a game called Human Resource Machine. It's basically assembly game. It has puzzles with progressively increasing difficulties and shows you the basics of it. Assembly is platform specific but the game gives the abstract of them all. I'd start with this game.
I don't think a procedure of any high level language can be contained in 64kBs and run on 2kBs of RAM. You need assembly for that.
It‚Äôs faster
Faster than numpy?  Seems unlikely.
If you get creative, absolutely. 
You a penguin? https://cdn.iwastesomuchtime.com/10152013232041.gif
Aka "R but expensive"
Eurgh, really....
Java can be pretty fast though...maybe not efficient in terms of lines of code needed.
Yep, and you spend 4 hours a day looking at documentation because a library that should contain 4 functions actually has to be made up of at least 12 classes (not including all the interfaces & factories!)
What specifically about documentation for Microsoft languages you think is worse than for Java?
I thought it was its backwards compatbility. Which is at the same time good and bad. 
I always thought PHP had really decent documentation too.  At least I had no trouble finding what I needed to do.
Last time I used Microsoft languages I found the documentation quite good.

Google's documentation however was horrendous.

It was a couple years ago though, so it may have changed somewhat.
C# is incredibly well-documented though?
If you need documentation, there is a problem.
If you don't need documentation, there is a problem. Assuming you know how to properly use a library without documentation is foolish. Also if your comment was more along the lines of, "I've memorized all needed documentation" that means you aren't learning anything new.
I think it's sometimes possible to write an API that's so intuitive that most people won't need to look at its documentation.

Though that is a goal that is not achievable most of the time, so good documentation is still crucial.
I think this depends on the domain. If the domain is something that's well understood (by the consumers, not the dev), it could be possible, but if there are any intracacies involved, you should have doc
I don‚Äôt think you have ever worked on a serious project before 
I have 5 years professional experience.  My statement was hyperbole, though that clearly didn't come across to the many people who down voted me.
That's where you're wrong!
A language without docs shouldn't even be considered by any person
I love Kotlin so much.  Coming from Java for Android development it has made my life approximately 1000x easier
> diabetes-inducing levels of syntactic sugar

[Perfection](http://i0.kym-cdn.com/entries/icons/original/000/022/900/704.jpg)
I've never actually used Kotlin. You're saying it's basically better Java? I'm sold.
I disagree. I've been dipping my toes in Java and I wish there was only one way. Yes, it's way more opinionated than weakly typed scripting languages like JavaScript or Ruby, but there are so many design/decorator patterns. I'm really hard on myself when it comes to organizing the classes in packages (how they should be broken up), as soon as I learned about POJOs I quickly learned about Builders. Any advice?
Use Kotlin instead
I would love to, but don't have that flexibility at work. How does Kotlin ease my concerns about patterns?
> it's C and C++

Objective-C is C++??
I am interested to learn ObjC, but now there's Swift so what's the deal?
Atleast in the newer versions of Android studio it would show up as 
new CountDownTimer( newWithTotalTime:3000 interval:1000)
With the parameter names being a different color, kind of like a hint.
Named paramaters!
You can theoretically declare all your parameters in C#, if you want, although it's mainly used in the case of overloaded functions.
I will agree Tomcat is trash
Tomcat's pretty bad, but doesn't really speak for the language itself.
From a user perspective, it also has the drawback of high usage \- lots of companies with no real interest in getting good developers program their programs in Java, which leads to really bad layouts and crappy performance often being attributed to the language, not the "better get that thing out with minimal work" culture of the \*supplier of scientific microscopes that has me click through three tabs that need 10 seconds each to load for every picture I take\* \>:o\(

I know it's not Java's fault, I just can't help my bias at this point...
good point, It's probably better to believe that somebody is identifying their favorite language rather then saying, "I only code exclusively in X"
Ya frankly I thought it was a Golang job because the coding challenge was in Golang and everything I had done prior to the technical interview was in Golang. But no, it was Ruby as well, and I pulled out of consideration.
Ooof
I have the fear that this never stops. Haskell is the deepest rabbit hole I ever dove into.
Don't get me fucking started on Javas so called *"functional"* features. What Java calls Lambdas is nothing but syntactic sugar for antonymous-inner-classes. Every choice they made realizing this feature is the worst one possible.
>and think white space should never be an operator

I've never understood this sentiment. I've been writing Python for over 5 years and I can't remember a single time where I had a bug caused by indentation. Plus, you're going to indent your code to denote flow and structure anyway. Why not have the language take the indentation into account so the code doesn't need to be cluttered with curly braces and semicolons?
Creators of Go: You want generics. We want generics. If you can figure out a way to do it extremely simply, we'll add it but your SOL until then because we haven't figured it out yet.
No, I'm melted\_Brain
Could we just replace it with "frontend-dev" altogether and put them somewhere at the bottom? :D
Why use my own CPU when I can use yours?
Well I‚Äôm not gonna use my own electricity to mine crypto. 
And every other. 
Haha, great stuff!
That's cool üòÉ
1 byte = 1 prayer
Don‚Äôt assume endianess 
I disagree, in an int you don't need to care about endianess, you do need to care about it if you write it byte by byte.

    int a = 12345678;
    printf("%d", a);

On a little endian machine: you get 12345678, on a big endian machine you get 12345678. Same for hex.

    int a = 0x12345678;
    printf("0x%X", a);

On a little endian machine: you get 0x12345678, on a big endian machine you get 0x12345678.

Whereas

    char *a = "\x12\x34\x56\x78";
    printf("0x%X", *(int *)a);

On a little endian machine you get 0x78563412, on a big endian machine you get 0x12345678.

So the opposite of what you said.
More often than not, some people do stuff become "computer science dogna no#random" without it really being applicable to the specific case. 
There is no issue, we have the final say. That being said, it's entirely possible some fire might erupt where the only solution is bad engineering, but we don't want to add tech debt without a solid reason.

And even then, you should put out the fire and pay back the debt.
My chart: Everyone else --> Me.

I'm depressed. :(
Fair! 
Oh, God, no.
I don't even write my HTML anymore, I just make Emmet do it for me. I just write the CSS selectors.
huh. Made by the same guys who did World of Goo. Now I need this!
you mean [shenzhen i/o](https://www.youtube.com/watch?v=geT2uP7MYGc)
Can you give me a controller name so I can check ?
I'm not sure. The constraints were present because there were many other modules working on the machine.
Considering rust, c++, c, etc will all compile down into platform-specific byte code, you don‚Äôt really have to write anything in assembly. 
That's why Groovy exists. 

(Prepared for the down votes.)
"I've got twenty lines of code spead across 13 files in 32 directories... In other words, it's perfect"

-Java developer
Are lines of code that important? I thought people disliked Java because it uses a garbage collector.
You have to differentiate between language and runtime / framework.

C# and VB.net are extensively documented, I think F# too.

The System.* and Microsoft.* namespaces in the framework however do have some under-documented areas, same goes for the runtime itself. I can't really compare to Java, but in my limited experience, Java also has some areas with shoddy documentation.

I had to manually craft a SOAP request in java (since all libraries failed me) and figuring out how to use javax.xml.soap.* was a pain the arse. But I had similar encounters with obscure parts of the .NET framework. Sadly, I don't have examples at hand.
ProjectServer for SharePoint

*I meant that as in the docs for ProjectServer only occasionally have useful information beyond the auto-generated api
MSDN has always been a confusing mess with the most difficult to follow examples (when there even are any) and the most esoterically worded explanations. However, Microsoft Docs is actually extremely good, some of the best docs on the internet IMO, so at least they're changing
I'm not really a programmer, but I work with Java a lot. For hobby projects, Kotlin is a lot of fun to learn and it's super compatible with Java, so you can use any Java library directly from Kotlin with no effort.
Like I said if you rename a Objective-C file (`file.m`) to `.mm` (`file.mm`) it becomes a Objective-C++ file. [Archive link to the sadly removed Apple doc article about it](http://web.archive.org/web/20101203170217/http://developer.apple.com/library/mac/#/web/20101204020949/http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html).

I said this assuming the comment I replied to talked about the Objective part of Objective-C and Objective-C++ (lot of people don't know both are possible). I edited to `C or C++` for [academic precision](https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B#Constructs_that_behave_differently_in_C_and_C++).
Learn Swift, it's the future. The performances are better and the language is beautiful and really easy to learn.

I only recommend Objective-C when : 

- You're not worried about NPEs
- You want a ultra-stable codebase, Swift ABI changes are pretty heavy and **you will** have weird problems in the build process (embedded libraries, your app/framework bloated with the std lib).
- You are making a framework and Objective-C people will use it
- You don't want to migrate your code each version
- You only care about Apple platforms (no Linux/Windows)
- IMHO it's **currently** easier to find excellent Objective-C developers than it is to find excellent Swift developers

Remember nothing is binary and it really depends. Except this, Swift is a very good language and IMO easily one of the best on the performance/readability/safety compromise with Rust and Kotlin Native.
True, but that's hardly Java's fault.
Enterprise scratch developer- Can confirm.
Unless they're a javascript developer, then they probably only know javascript.
Owie my brain hurting juice 
It's basically because the code structure is tied to HOW the text is aligned rather than the content of the text. I think content should be the only thing that matters.
I actually think forcing whitespace like this makes it a great first language as it makes you have at least decent formatting.
Agreed. Helps enforce proper habits.
Oh no it's worse than I thought
Hey hey, we have feelings too you know...

Jk, all my feelings got stripped away by using JS.
A kid just went un-shot.
This is so sad. Can we get 50 bytes?
Did you just assume my endianess?
That's not what I meant. If I have a shell code, so I want to write binary code, then I need to care about endianess when writing it as an integer, but not when writing it as a byte array. Of course when you want a number and write the binary representation you need to care.
Someone recently wanted to expose a more generic SQL interface to the API. Security concerns aside, if someone runs a stupidly complex sql query against the database it will affect others using the Db.

Them: We'll profile test our queries. 

Me: But will the next team? Will the next team member when you're gone.

Infra teams are responsible for the health of the system as a whole. 


I just want to say, I wish I worked with more people like you. 
Yeah, it's very engaging and very hard if you want to complete challenges. They limit your use of instructions and run time. They teach you how to optimize your assembly macros.
One of them only I think?

Great game, but gets a bit tedious at the later levels I think. It is a lot of fun to try to solve each puzzle both in the fastest and shortest way (for both awards).
There's also tis-100 but hrm is very basic and easier to get into.
But you lose type safety. I use groovy for scripting, but I like kotlin for type safety
Yea or kotlin or Scala or whatever
> I have more files and lines therefore it's automatically worse.

-people who don't understand encapsulation or want to use java for something where some other language would be better suited 
Hey, codis122590, just a quick heads-up:  
**accross** is actually spelled **across**. You can remember it by **one c**.  
Have a nice day!

^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Lines of code are generally considered a bad thing because it creates more opportunities for bugs and is harder to maintain. A lot of lines in java are boilerplate instead of actual code so this doesn't apply completely. Still, having a a state machine spread across 40 files is a lot of boilerplate and separation that makes it a pain to read.

Java's type system is more powerful than most people give it credit for but if you really use wildcards or recursive bounds for abstractions most people look at you funny.
I personally don't think lines of code are too important. As for the garbage collector, I feel like 99% of projects won't be impacted by it. I know it's pretty tunable as well. Would love to hear someone's experience that came up against it as a bottleneck.
Garbage collection is great. I wish I had it in real life. I could leave my dirty dishes on the table, my trash wherever I want, and some magic genie cleans it up when I'm not looking. Perfect.
I can't speak for anyone else, so *personally* I find that Java's verbosity isn't so much a problem as what *causes* the verbosity. If Java had a standard way to access members, then we wouldn't be in this mess. But no, there is no standard. There's a convention called Java beans, but it's followed so inconsistently that it might as well not even exist. This means that whenever you need to access a member of a class, you need to do it in whatever specific, Arcane way the author of that class decided was appropriate. So reading code is a nightmare, because even something simple is likely to be surprising. Additionally, code cannot be reused at all between generic-seeming cases, as a line written to call one class' "int getX()" isn't going to work to call another's "ProjectSpcific.Maybe<int> get_position_x()" isn't going to work for "int getIntMember(String propname)", and the first "int getX()" isn't the same as another "int getX()" because the second one isnt idempotent, and all of this even if they're in the same bloody library! (I'm looking at you, JavaFX.) This means that to be sane, one must write their own wrapper classes around everything, and rewrite the same code multiple times, and all sorts of other patterns which mean that what should be a very simple project ends up as a Herculean repo. 

Of special importance, I feel, is that Java doesn't have a standard way to serialize stuff. This means that any Library which wants to write out data, needs to rely on either some third-party Library like Jackson, which they use inconsistently with one another (see above), or they write their own serialization strategy. The fact that Json is ubiquitous is a bit of a blessing here, but you'll still find plenty of useful stuff that uses binary blobs, CSV, XML, or anything else as their io format. Not so bad, until you write the code that translates all this stuff around.

All of the above and more, means that to do any damn nontrivial thing in this "high level language", you first need to write all the low-level crap that makes the high-level stuff possible.

Why do we continue to write Java? Because the JVM is a slick piece of tech. Seriously, the JVM makes some of this worth it. That garbage collector? Best in the business. Class paths are neat. Etc etc etc. This is also why there are so many different JVM languages. There's also Android dev, which is okay I guess.

Edit - for a good look into how absurd Java programming is, read the most recent edition of Effective Java. Its also required reading if you ever want to do anything with the language. Not with other jvm languages necessarily, as each one tries to fix these issues in its own way. 
For mscorlib it is often easier just to dive straight into an ILSpy (or similar) disassembly of the library than follow the documentation. The docs do sometimes clarify why things are a certain way, but to understand how they work under the hood, they're useless.    

This is particularly true when performance optimizing critical sections of code, for example just understanding some of the error checking code (and if it applies to your usage) then bypassing it can be quite a bump on something called tens of thousands of times.    
Like if you rename a C file (`file.c`) to `.cc` (`file.cc`) it becomes a C++ file?
The following is written in a semi-sarcastic and slightly facetious manner. It is not intended to offend in any way.

Ah. You see, I think this is the line. I think we finally found it. The true difference between semicolon lovers and whitespace lovers. I think it is the for loop.

A semicolon lover loves to write a for loop as such:
```javascript
for (var i = 0; i< 10; i++) {console.log(i**2);}
```

Whereas a whitespace lover would consider that disgusting. They would much prefer:
```python
for i in range(11):
    print(i**2)
```

That's got to be it, the ability to write a short statement/flow as a single line.


For god sake man, ask for 64....
F
0x0F
How so? Groovy can be typed and you can use Compile Static. 
Kotlin is for people who are too scared of scala. Also scala is pure madness, I recently spend 3 months reverse engineering someone elses code.
I mean, I hear ya, but my source doesn't have to be nested 8 levels deep in order to be well organized
> You can remember it by one c

Am I missing something or is the the most useless spelling tip ever?
bad bot
> You can remember it by one c.

Hey kids, quick tip on how to spell `across`: type out "across" with your fingers!
Good bot
Yeah I have come up against it as a bottleneck. I was coding up some funky binary tree structures which produced some deep stacks, and had some automated tests running that would fail due to some issue with the garbage collector. I can't recall *exactly* what the issue was but I had to modify my tests to make it work (the tests were still complete and valid I just had to run them in batches and much around with some parameters). But yes the collector can cause issues when you push the language to the extremes.

Edit: It just came back to me, the issue was actually with JDBC.
Haven't worked with it intensively enough to come across such limitations personally but in my intro languages class I remember a key example being you would never want to write something like a daemon in Java (at least without heavy garbage collection modifications I imagine, wouldn't even know where to begin) because something like that constantly running on an always-on server would inevitably choke RAM with garbage until the system halts. Not sure how realistic that is again, but it's sort of how I understand it.
Exactly, that's the best analogy
Wait, isn't typed Groovy just Java? 
*Can* not *Is*. Which is a giant difference
Kotlin is for people who like java but just want it to be better at being java. It's java but better, prettier, and safer (no more null pointer exceptions)

Scala is for people who like java but want it to be totally different.
yours maybe not but it helps when debugging/ trying to understand some 10 year old code. similarly it will help when someone is trying to understand your code down the line
You can remember how to spell it by the way it's spelled.
Across the one C.

Not useless to me!

There are plenty of tips that are made by real dips, but this one is smart as can be!
Also an incredibly useless bot.
I find it a little condescending sometimes. Like "Oh, you probably just don't know how to spell the word; there's just no way you could have made a typo".
Well, JDBC drivers its native aka in C...
The problem is, bigger daemons have bigger chance of leaks and smaller ones are completely outclassed by anything - VM takes quite a bit of memory for itself.
No, that's literally what happens.
Yeaaa I know. That's why I said it's the best analogy. Am I missing something? Perhaps [this may help](http://www.dictionary.com/browse/analogy).
It's Java\+\+.
I'm talking about empty directories that don't contain anything other than another directory. Go take a look at nutch (or probably just about any open source Java app). All the plugins are nested like:

<pluginName>/src/Java/org/<organization name>/<product name>/<plugin name again>/<actual doc root>


Nothing between 'src' the actual doc root have anything in them. It's unnecessary.


https://github.com/apache/nutch/tree/master/src/plugin/index-static/src
they are package names I am not sure how else would you solve it
And so? github/gitlab squashes them. IDEs squash them into packages.

People pick such non-issues to shit on Java, like directory nesting or long Hello World.
